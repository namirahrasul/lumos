var Visitor, readFileSync, javascript_module, op, JavascriptVisitor, visitor;
Visitor = require('./base').Visitor;
readFileSync = require('fs').readFileSync;
javascript_module = readFileSync(__dirname + "/validatr.js.js", 'utf-8');
op = {
  "is": " === ",
  "is not": " !== ",
  ">": " > ",
  ">=": " >= ",
  "<": " < ",
  "<=": " <= ",
  "in": " __in ",
  "not in": " not in ",
  "and": " && ",
  "or": " || "
};
JavascriptVisitor = (function(_super){
  JavascriptVisitor.displayName = 'JavascriptVisitor';
  var prototype = __extends(JavascriptVisitor, _super).prototype, constructor = JavascriptVisitor;
  function JavascriptVisitor(){
    JavascriptVisitor.superclass.apply(this, arguments);
    this.indentation = 2;
    this.declarations = [];
  }
  prototype.assign = (function(){
    function assign(node){
      return "'" + node.name + "'";
    }
    return assign;
  }());
  /**
   *  Since we're dealing with python, we need some indentation to be done.
   *  Indentation is computed with @indentation
   *
   *  @param text The text we need to indent.
   */
  prototype.indent = (function(){
    function indent(text){
      var indent, i, t;
      indent = __repeatString("    ", this.indentation);
      return (function(){
        var _ref, _len, _results = [];
        for (i = 0, _len = (_ref = text.split('\n')).length; i < _len; ++i) {
          t = _ref[i];
          _results.push(t && i > 0 ? indent + t : t);
        }
        return _results;
      }()).join('\n');
    }
    return indent;
  }());
  /**
   *  Visit a node and indent its result to the current level of indentation.
   *
   *  @param node the node to visit
   *  @param ind the level of indentation : replaces @indentation or takes
   *      its value if nothing is provided.
   */
  prototype.visit = (function(){
    function visit(node, ind){
      var bak, s;
      ind == null && (ind = this.indentation);
      bak = this.indentation;
      this.indentation = ind;
      s = JavascriptVisitor.superclass.prototype.visit.call(this, node);
      s = this.indent(s);
      this.indentation = bak;
      return s;
    }
    return visit;
  }());
  prototype.opts = (function(){
    function opts(node, res){
      if (node.validation) {
        res.push("function (x, ctx) { return " + this.visit(node.validation, 0) + "; }");
      }
      if (node.assign) {
        res.push("'" + node.assign.name + "'");
      }
      if (node['default']) {
        res.push("Default(" + this.visit(node['default'], 0) + ")");
      }
      return res;
    }
    return opts;
  }());
  prototype.simpleops = (function(){
    function simpleops(node){
      var res;
      res = [];
      this.opts(node, res);
      return res.join(", ");
    }
    return simpleops;
  }());
  return JavascriptVisitor;
}(Visitor));
/**
 *
 */
visitor = new JavascriptVisitor({
  /**
   *
   */
  TypeChoice: (function(){
    function TypeChoice(node){
      var choices, t, _i, _ref, _len;
      choices = [];
      for (_i = 0, _len = (_ref = node.types).length; _i < _len; ++_i) {
        t = _ref[_i];
        choices.push(this.visit(t, 1));
      }
      choices = choices.join(", ");
      return "TChoice(" + choices + ")";
    }
    return TypeChoice;
  }())
  /**
   *
   */,
  TypeObject: (function(){
    function TypeObject(node){
      var args;
      args = [this.visit(node.properties, 1)];
      this.opts(node, args);
      args = args.join(", ");
      return "TObject(" + args + ")";
    }
    return TypeObject;
  }())
  /**
   *
   */,
  TypePropertyList: (function(){
    function TypePropertyList(node){
      var res, p, _i, _ref, _len;
      res = [];
      for (_i = 0, _len = (_ref = node.list).length; _i < _len; ++_i) {
        p = _ref[_i];
        res.push(this.visit(p));
      }
      if (res.length === 0) {
        return '';
      }
      res = res.join(",\n");
      return "TProperties(" + res + ")";
    }
    return TypePropertyList;
  }())
  /**
   *
   */,
  TypeProperty: (function(){
    function TypeProperty(node){
      var args;
      args = [this.visit(node.name)];
      args.push(this.visit(node.inner_type));
      this.opts(node, args);
      args = args.join(", ");
      return "TProperty(" + args + ")";
    }
    return TypeProperty;
  }())
  /**
   *
   */,
  TypeArray: (function(){
    function TypeArray(node){
      var args, inner;
      args = [];
      inner = this.visit(node.inner_type);
      if (inner) {
        args.push(inner);
      }
      this.opts(node, args);
      args = args.join(", ");
      return "TArray(" + args + ")";
    }
    return TypeArray;
  }())
  /**
   *
   */,
  TypeRef: (function(){
    function TypeRef(node){
      var decl;
      decl = "var " + node.name + " = " + this.visit(node.type, 0);
      this.declarations.push(decl);
      return node.name;
    }
    return TypeRef;
  }()),
  TypeDate: (function(){
    function TypeDate(node){
      return "TDate(" + this.simpleops(node) + ")";
    }
    return TypeDate;
  }()),
  TypeRefCall: (function(){
    function TypeRefCall(node){
      return node.name;
    }
    return TypeRefCall;
  }()),
  TypeString: (function(){
    function TypeString(node){
      return "TString(" + this.simpleops(node) + ")";
    }
    return TypeString;
  }()),
  TypeUndefined: (function(){
    function TypeUndefined(node){
      return "TUndefined(" + this.simpleops(node) + ")";
    }
    return TypeUndefined;
  }()),
  TypeNumber: (function(){
    function TypeNumber(node){
      return "TNumber(" + this.simpleops(node) + ")";
    }
    return TypeNumber;
  }()),
  TypeBoolean: (function(){
    function TypeBoolean(node){
      return "TBoolean(" + this.simpleops(node) + ")";
    }
    return TypeBoolean;
  }()),
  TypeNull: (function(){
    function TypeNull(node){
      return "TNull(" + this.simpleops(node) + ")";
    }
    return TypeNull;
  }()),
  TypeAnything: (function(){
    function TypeAnything(node){
      return "";
    }
    return TypeAnything;
  }())
  /**
   *
   */,
  LString: (function(){
    function LString(node){
      return "'" + node.str + "'";
    }
    return LString;
  }()),
  LNumber: (function(){
    function LNumber(node){
      return node.num;
    }
    return LNumber;
  }()),
  LVariable: (function(){
    function LVariable(node){
      if (node.name) {
        return "ctx.vars['" + node.name + "']";
      } else {
        return "x";
      }
    }
    return LVariable;
  }()),
  LFunCall: (function(){
    function LFunCall(node){
      var ar, a, _i, _ref, _len;
      ar = [];
      for (_i = 0, _len = (_ref = node.args).length; _i < _len; ++_i) {
        a = _ref[_i];
        ar.push(this.visit(a));
      }
      ar = ar.join(", ");
      return node.name + "(" + ar + ")";
    }
    return LFunCall;
  }()),
  LList: (function(){
    function LList(node){
      var elts, e, _i, _ref, _len;
      elts = [];
      for (_i = 0, _len = (_ref = node.list).length; _i < _len; ++_i) {
        e = _ref[_i];
        elts.push(this.visit(e, 0));
      }
      if (elts.length === 0) {
        elts = ['', ''];
      }
      if (elts.length === 1) {
        elts.push('');
      }
      return "[" + elts.join(", ") + "]";
    }
    return LList;
  }()),
  LBoolean: (function(){
    function LBoolean(node){
      if (node.value) {
        return 'True';
      }
      return 'False';
    }
    return LBoolean;
  }()),
  LUndefined: (function(){
    function LUndefined(node){
      return "undefined";
    }
    return LUndefined;
  }()),
  LNull: (function(){
    function LNull(node){
      return "null";
    }
    return LNull;
  }()),
  BinaryOperator: (function(){
    function BinaryOperator(node){
      var s;
      s = [];
      s.push("(");
      if (node.op !== 'in') {
        s.push(this.visit(node.left, 0));
        if (node.negated) {
          s.push(op[node.not_op]);
        } else {
          s.push(op[node.op]);
        }
        s.push(this.visit(node.right, 0));
      } else {
        if (node.negated) {
          s.push("!");
        }
        s.push("__in(");
        s.push(this.visit(node.left, 0));
        s.push(", ");
        s.push(this.visit(node.right, 0));
        s.push(")");
      }
      s.push(")");
      return s.join("");
    }
    return BinaryOperator;
  }()),
  CIf: (function(){
    function CIf(node){
      var args;
      args = [];
      args.push("function (x, ctx){ return " + this.visit(node.cond) + "; }");
      args.push(this.visit(node.then, 1));
      if (node.otherwise) {
        args.push(this.visit(node.otherwise, 1));
      }
      args = args.join(",\n");
      return "TIf(" + args + ")";
    }
    return CIf;
  }())
});
exports.javascriptVisitor = {
  visit: (function(){
    function visit(node, options){
      var visit, mod;
      options == null && (options = {});
      visit = visitor.visit(node, 0);
      mod = javascript_module.toString();
      return "" + mod + "\n\nfunction length (elt) {\n    // FIXME object length ??\n    return elt.length;\n}\n\n" + visitor.declarations.join("\n\n") + (visitor.declarations.length > 0 ? "\n\n" : "") + "\nexports.validator = " + visit + ";";
    }
    return visit;
  }())
};
function __extends(sub, sup){
  function ctor(){} ctor.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new ctor).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function __repeatString(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}