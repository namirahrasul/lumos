exports.source = "import string\nfrom datetime import date, datetime, time\n\ndef pathjoin(path1, path2):\n    arr = []\n    if path1: arr.append(path1)\n    if path2: arr.append(path2)\n    return string.join(arr, '.')\n\nclass Undefined:\n    pass\n\nclass Context(dict):\n    def __init__(self, *args, **kwargs):\n        super(Context, self).__init__(*args, **kwargs)\n        self.errors = []\n        self.displayErrors = True\n\n    def appendError(self, path, msg):\n        if self.displayErrors:\n            self.errors.append( (path, msg) )\n\nclass Validator(object):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        if \"assign\" in kwargs:  \n            self.assign = kwargs[\"assign\"]\n        if \"validation\" in kwargs:\n            self.validation = kwargs[\"validation\"]\n\n    def validate(self, node, ctx=Context(), path=''):\n        \"\"\" Perform standard validation.\n        \"\"\"\n\n        if \"assign\" in self.__dict__:\n            ctx[self.assign] = node\n\n        if \"validation\" in self.__dict__:\n            res = self.validation(node, ctx)\n            if not res:\n                ctx.appendError(path, \"validation not passed\")\n            return res\n\n        return True\n\n    def assign(self, node, ctx):\n        \"\"\" Assign a variable in the context.\n        \"\"\"\n        ctx[self.assign] = node\n\n################ Types #####################\n\nclass SimpleValidator(Validator):\n\n    def __init__(self, **kwargs):\n        super(SimpleValidator, self).__init__(**kwargs)\n\n    def validate(self, node, ctx=Context(), path=''):\n        res = self._validate(node)\n        if not res:\n            ctx.appendError(path, \"not the correct type\")\n\n        return res and super(SimpleValidator, self).validate(node, ctx, path)\n\n    def _validate(self, node):\n        raise NotImplemented(\"Not implemented\")\n\nclass TDate(SimpleValidator):\n    \"\"\" A Date.\n    \"\"\"\n    pass\n\nclass TBoolean(SimpleValidator):\n    def _validate(self, node):\n        return node is True or node is False\n\nclass TNumber(SimpleValidator):\n    \"\"\" A Number\n    \"\"\"\n    def _validate(self, node):\n        return (isinstance(node, int) or isinstance(node, float)) and not isinstance(node, bool)\n\nclass TString(SimpleValidator):\n    \"\"\" A String\n    \"\"\"\n    def _validate(self, node):\n        return isinstance(node, unicode) or isinstance(node, str)\n\nclass TUndefined(SimpleValidator):\n    def _validate(self, node):\n        return node is Undefined\n\nclass TNull(SimpleValidator):\n    def _validate(self, node):\n        return node is None\n        \n#########################################################\n\nclass TProperties(Validator):\n    def __init__(self, *args, **kw):\n        self.properties = args\n        super(TProperties, self).__init__(**kw)\n\n    def validate(self, node, ctx=Context(), path=''):\n        res = True\n        for p in self.properties:\n            res = p.validate(node, ctx, path) and res\n        return res\n\nclass TProperty(Validator):\n    def __init__(self, name, typ, **kw):\n        self.typ = typ\n        self.name = name\n\n        if \"default\" in kw:\n            self.default = kw[\"default\"]\n\n        super(TProperty, self).__init__(**kw)\n\n    def validate(self, node, ctx=Context(), path=''):\n        path = pathjoin(path, self.name)\n        prop = node.get(self.name, Undefined)\n\n        if prop is Undefined and \"default\" in self.__dict__:\n            node[self.name] = self.default\n            prop = self.default\n\n        return self.typ.validate(prop, ctx, path) and \\\n            super(TProperty, self).validate(prop, ctx, path)\n\nclass TObject(Validator):\n    \"\"\" An Object, that can contain properties.\n    \"\"\"\n\n    def __init__(self, *args, **kw):\n        self.properties = args\n        super(TObject, self).__init__(**kw)\n\n    def validate(self, node, ctx=Context(), path=''):\n        if not hasattr(node, \"iteritems\"):\n            ctx.appendError(path, \"not an object\")\n            return False\n\n        res = True\n        for o in self.properties:\n            res = o.validate(node, ctx, path) and res\n\n        return super(TObject, self).validate(node, ctx, path) and res\n\nclass TArray(Validator):\n    def __init__(self, typ=None, **kw):\n        self.typ = typ\n        super(TArray, self).__init__(**kw)\n\n    def validate(self, node, ctx=Context(), path=''):\n        if not hasattr(node, \"__iter__\") or hasattr(node, \"iteritems\"):\n            ctx.appendError(path, \"not an array\")\n            return False\n\n        res = True\n        if self.typ:\n            for idx, o in enumerate(node):\n                res = self.typ.validate(o, ctx, pathjoin(path, unicode(idx))) and res\n\n        return super(TArray, self).validate(node, ctx, path) and res\n        \n\nclass TChoice(Validator):\n    def __init__(self, *choices, **kw):\n        self.choices = self.parseArgs(choices)\n        super(TChoice, self).__init__(**kw)\n\n    def validate(self, node, ctx=Context(), path=''):\n        # Inhibit the error reporting, since some\n        # of the choices WILL fail.\n        ctx.displayErrors = False\n\n        found_one = False\n        for c in self.choices:\n            if found_one:\n                break\n            found_one = c.validate(node, ctx, path)\n\n        ctx.displayErrors = True\n\n        return super(TChoice, self).validate(node, ctx, path) and found_one\n\n\nclass TIf(Validator):\n    def __init__(self, cond, then, otherwise=None):\n        self.cond = cond\n        self.then = then\n        self.otherwise = otherwise\n\n    def validate(self, node, ctx=Context(), path=''):\n        if self.cond(node, ctx):\n            return self.then.validate(node, ctx, path)\n        else:\n            if self.otherwise:\n                return self.otherwise.validate(node, ctx, path)\n        return True\n\n";